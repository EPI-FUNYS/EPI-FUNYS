<!DOCTYPE html>
<html>
<head>
    <title>Song Badness Index</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Add both compression libraries -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <!-- Load Roboto font -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        /* Same styles as before, plus a toggle for compression method */
        .compression-note {
            font-size: 0.8em;
            color: #a0f0ff;
            margin-top: 5px;
            opacity: 0.8;
        }
    </style>
</head>
<body>

<h1>ðŸŽµ Song Badness Index (0â€“25)</h1>

<div class="container">
    <input type="text" id="songInput" placeholder="Song name">
    <input type="text" id="artistInput" placeholder="Artist">
    <input type="number" id="scoreInput" min="0" max="25" placeholder="0-25">
    <input type="url" id="linkInput" placeholder="Song link (optional)">
    <button id="addBtn">Rate Song</button>
    <button id="resetBtn">Reset</button>
    <button id="shareBtn">ðŸ”— Share Rankings</button>
    <div class="compression-note" id="compressionNote"></div>

    <canvas id="myChart"></canvas>

    <div class="ranking">
        <h3>ðŸ”¥ Worst â†’ Least Bad</h3>
        <div id="rankingList"></div>
    </div>
</div>

<!-- Modal for share link -->
<div class="modal-bg" id="shareModalBg">
    <div class="modal">
        <p>ðŸ“‹ Shareable link</p>
        <div class="share-link-box" id="shareLinkDisplay"></div>
        <p id="linkStats" style="font-size: 0.8em; color: #88ff88;"></p>
        <div class="modal-buttons">
            <button class="btn-copy" id="copyLinkBtn">Copy Link</button>
            <button class="btn-close" id="closeShareModalBtn">Close</button>
        </div>
    </div>
</div>

<!-- Modal for confirm/cancel -->
<div class="modal-bg" id="modalBg">
    <div class="modal">
        <p id="modalText">Are you sure?</p>
        <div class="modal-buttons">
            <button class="btn-confirm" id="modalYes">Yes</button>
            <button class="btn-cancel" id="modalNo">No</button>
        </div>
    </div>
</div>

<script>
window.addEventListener('load', function(){
    if (Chart) {
        Chart.defaults.font.family = "Roboto, 'Segoe UI', sans-serif";
    }

    const STORAGE_KEY = 'songsData';
    const ctx = document.getElementById('myChart').getContext('2d');
    let songs = [];
    let actionType = null;
    let songToRemoveIndex = null;

    const modalBg = document.getElementById('modalBg');
    const modalText = document.getElementById('modalText');
    const modalYes = document.getElementById('modalYes');
    const modalNo = document.getElementById('modalNo');

    const shareModalBg = document.getElementById('shareModalBg');
    const shareLinkDisplay = document.getElementById('shareLinkDisplay');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const closeShareModalBtn = document.getElementById('closeShareModalBtn');
    const linkStats = document.getElementById('linkStats');
    const compressionNote = document.getElementById('compressionNote');

    // --- ULTIMATE COMPRESSION ---
    function ultraCompress(songs) {
        // Step 1: Extreme property minification (use array format)
        // This alone saves ~40% compared to object format
        const minimized = songs.map(s => {
            // Encode score as a single character (0-25 -> 0-9A-P)
            const scoreChar = s.score < 10 ? s.score.toString() : String.fromCharCode(65 + (s.score - 10));
            
            // Return as flat array for maximum density
            return [
                s.name,
                s.artist,
                scoreChar,
                s.link ? s.link.replace(/https?:\/\/(www\.)?/, '') : '' // Remove common prefixes
            ];
        });
        
        // Step 2: Convert to JSON
        const jsonStr = JSON.stringify(minimized);
        
        // Step 3: Try both compressors and pick the smallest
        const lzCompressed = LZString.compressToEncodedURIComponent(jsonStr);
        
        // For pako, we need to convert to base64
        const deflated = pako.deflate(jsonStr, { level: 9 });
        const deflatedBase64 = btoa(String.fromCharCode.apply(null, deflated))
            .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        
        // Add a marker to know which compression to use
        const lzResult = 'l' + lzCompressed;
        const pakoResult = 'p' + deflatedBase64;
        
        // Return the shorter one
        return lzResult.length < pakoResult.length ? lzResult : pakoResult;
    }

    function ultraDecompress(compressedStr) {
        try {
            const marker = compressedStr[0];
            const actualData = compressedStr.substring(1);
            
            let jsonStr;
            if (marker === 'l') {
                // LZ-String
                jsonStr = LZString.decompressFromEncodedURIComponent(actualData);
            } else if (marker === 'p') {
                // Pako
                const base64 = actualData.replace(/-/g, '+').replace(/_/g, '/');
                while (base64.length % 4) base64 += '=';
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                jsonStr = pako.inflate(bytes, { to: 'string' });
            } else {
                throw new Error('Unknown compression method');
            }
            
            const minimized = JSON.parse(jsonStr);
            
            // Expand back
            return minimized.map(m => ({
                name: m[0],
                artist: m[1],
                score: typeof m[2] === 'string' ? 
                    (m[2] < 'A' ? parseInt(m[2]) : 10 + (m[2].charCodeAt(0) - 65)) : 
                    m[2],
                link: m[3] ? 'https://' + m[3] : null // Re-add prefix if needed
            }));
        } catch (e) {
            console.warn("Decompression failed", e);
            return null;
        }
    }

    // --- URL parameter loading ---
    function loadFromURLParams() {
        const urlParams = new URLSearchParams(window.location.search);
        const dataParam = urlParams.get('u'); // 'u' for ultra-compressed
        
        if (dataParam) {
            try {
                const decompressed = ultraDecompress(dataParam);
                if (decompressed) {
                    songs = decompressed;
                    songs.sort((a,b) => b.score - a.score);
                    saveSongs();
                    compressionNote.textContent = `âœ… Loaded ${songs.length} songs from share link`;
                }
            } catch (e) {
                console.warn("Failed to load shared data", e);
                compressionNote.textContent = "âŒ Failed to load shared data";
            }
        } else {
            // Try old formats for backward compatibility
            const oldParam = urlParams.get('c');
            if (oldParam) {
                try {
                    const jsonStr = LZString.decompressFromEncodedURIComponent(oldParam);
                    const parsed = JSON.parse(jsonStr);
                    if (Array.isArray(parsed)) {
                        songs = parsed;
                        songs.sort((a,b) => b.score - a.score);
                        saveSongs();
                    }
                } catch (e) {}
            } else {
                const stored = localStorage.getItem(STORAGE_KEY);
                if(stored){
                    try {
                        const parsed = JSON.parse(stored);
                        if(Array.isArray(parsed)) songs = parsed;
                    } catch(e){ songs = []; }
                }
            }
        }
    }

    loadFromURLParams();

    const chart = new Chart(ctx, {
        type: 'bar',
        data: { labels: [], datasets: [{ data: [], backgroundColor: [], borderRadius: 6, barThickness: 25 }] },
        options: {
            indexAxis: 'y',
            animation: { duration: 800 },
            scales: {
                x: { 
                    beginAtZero: true, max:25, 
                    grid: { color:"rgba(255,255,255,0.1)" },
                    ticks: { 
                        color:"white", 
                        font: { family:'Roboto', size:14, weight:'500' }
                    }
                },
                y: { 
                    grid:{display:false}, 
                    ticks:{ 
                        color:"white", 
                        autoSkip:false, 
                        font:{ family:'Roboto', size:14, weight:'bold' }
                    } 
                }
            },
            plugins:{
                legend:{ display:false },
                tooltip:{
                    titleFont:{ family:'Roboto', size:14, weight:'500' },
                    bodyFont:{ family:'Roboto', size:13, weight:'400' },
                    callbacks:{ 
                        label: ctx=> `${songs[ctx.dataIndex].score}/25 â€” ${songs[ctx.dataIndex].artist}` 
                    }
                }
            }
        }
    });

    function saveSongs(){ 
        localStorage.setItem(STORAGE_KEY, JSON.stringify(songs)); 
    }

    function getColorByScore(score) {
        score = Math.min(25, Math.max(0, score));
        let hue;
        if (score <= 5) {
            hue = 120 - (score / 5) * 60;
        } else if (score <= 14) {
            const t = (score - 5) / (14 - 5);
            hue = 60 - t * 30;
        } else if (score <= 19) {
            const t = (score - 14) / (19 - 14);
            hue = 30 - t * 15;
        } else {
            const t = (score - 19) / (25 - 19);
            hue = 15 - t * 15;
        }
        return `hsl(${hue}, 100%, 50%)`;
    }

    function updateChart(){
        chart.data.labels = songs.map(s => s.name.length>25 ? s.name.substring(0,25)+'...' : s.name);
        chart.data.datasets[0].data = songs.map(s=>s.score);
        chart.data.datasets[0].backgroundColor = songs.map(s => getColorByScore(s.score));
        chart.update();
    }

    function updateRanking(){
        const list = document.getElementById('rankingList');
        list.innerHTML = '';
        songs.forEach((s,i)=>{
            const div = document.createElement('div');
            div.className='song-item';

            const text = document.createElement('span');
            if(s.link){
                const link = document.createElement('a');
                link.href = s.link;
                link.target = "_blank";
                link.textContent = i===0
                    ? `ðŸ‘‘ #1 WORST â€” ${s.name} by ${s.artist} â€” ${s.score}/25`
                    : `#${i+1} â€” ${s.name} by ${s.artist} â€” ${s.score}/25`;
                text.appendChild(link);
            } else {
                text.textContent = i===0
                    ? `ðŸ‘‘ #1 WORST â€” ${s.name} by ${s.artist} â€” ${s.score}/25`
                    : `#${i+1} â€” ${s.name} by ${s.artist} â€” ${s.score}/25`;
            }

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                songToRemoveIndex = i;
                actionType = "remove";
                modalText.textContent = `Are you sure you want to remove "${s.name}" by ${s.artist}?`;
                modalBg.style.display = 'flex';
            });

            div.appendChild(text);
            div.appendChild(removeBtn);
            list.appendChild(div);
        });
    }

    modalYes.addEventListener('click', () => {
        if(actionType === "remove" && songToRemoveIndex !== null){
            songs.splice(songToRemoveIndex, 1);
        } else if(actionType === "reset"){
            songs = [];
        }
        songToRemoveIndex = null;
        actionType = null;
        saveSongs();
        updateChart();
        updateRanking();
        modalBg.style.display = 'none';
    });

    modalNo.addEventListener('click', () => {
        songToRemoveIndex = null;
        actionType = null;
        modalBg.style.display = 'none';
    });

    // --- Share with ultra compression ---
    function generateShareableLink() {
        if (songs.length === 0) {
            alert("Add some songs first before sharing!");
            return null;
        }
        
        const compressed = ultraCompress(songs);
        const url = new URL(window.location.href);
        url.search = ''; // Clear all params
        url.searchParams.set('u', compressed);
        
        // Calculate compression ratio
        const originalJson = JSON.stringify(songs);
        const compressionRatio = ((1 - compressed.length / originalJson.length) * 100).toFixed(1);
        linkStats.textContent = `ðŸ“Š ${songs.length} songs â€¢ Original: ${originalJson.length} chars â€¢ Compressed: ${compressed.length} chars â€¢ Saved ${compressionRatio}%`;
        
        return url.toString();
    }

    document.getElementById('shareBtn').addEventListener('click', () => {
        const link = generateShareableLink();
        if (link) {
            shareLinkDisplay.textContent = link;
            shareModalBg.style.display = 'flex';
        }
    });

    copyLinkBtn.addEventListener('click', () => {
        const link = shareLinkDisplay.textContent;
        if (link) {
            navigator.clipboard.writeText(link).then(() => {
                alert('Link copied to clipboard!');
            }).catch(() => {
                alert('Press Ctrl+C to copy the link manually.');
            });
        }
    });

    closeShareModalBtn.addEventListener('click', () => {
        shareModalBg.style.display = 'none';
    });

    shareModalBg.addEventListener('click', (e) => {
        if (e.target === shareModalBg) {
            shareModalBg.style.display = 'none';
        }
    });

    function addSong(){
        const nameEl = document.getElementById('songInput');
        const artistEl = document.getElementById('artistInput');
        const scoreEl = document.getElementById('scoreInput');
        const linkEl = document.getElementById('linkInput');

        const name = nameEl.value.trim();
        const artist = artistEl.value.trim();
        const score = parseInt(scoreEl.value);
        const link = linkEl.value.trim();

        let invalid = false;

        if(!name) { 
            nameEl.classList.add('flash'); 
            invalid = true; 
            setTimeout(() => nameEl.classList.remove('flash'), 350);
        }
        if(!artist) { 
            artistEl.classList.add('flash'); 
            invalid = true; 
            setTimeout(() => artistEl.classList.remove('flash'), 350);
        }
        if(isNaN(score) || score<0 || score>25) { 
            scoreEl.classList.add('flash'); 
            invalid = true; 
            setTimeout(() => scoreEl.classList.remove('flash'), 350);
        }
        if(invalid) return;

        songs.push({name, artist, score, link: link || null});
        songs.sort((a,b)=>b.score - a.score);
        saveSongs();
        updateChart();
        updateRanking();

        nameEl.value='';
        artistEl.value='';
        scoreEl.value='';
        linkEl.value='';
        
        compressionNote.textContent = `${songs.length} songs â€¢ Click ðŸ”— Share to create a shareable link`;
    }

    function resetAll(){
        actionType = "reset";
        modalText.textContent = `Are you sure you want to reset all songs?`;
        modalBg.style.display = 'flex';
    }

    document.getElementById('addBtn').addEventListener('click', addSong);
    document.getElementById('resetBtn').addEventListener('click', resetAll);

    if(songs.length > 0) {
        songs.sort((a,b)=>b.score - a.score); 
        updateChart(); 
        updateRanking();
        compressionNote.textContent = `${songs.length} songs â€¢ Click ðŸ”— Share to create a shareable link`;
    }
});
</script>

</body>
</html>
